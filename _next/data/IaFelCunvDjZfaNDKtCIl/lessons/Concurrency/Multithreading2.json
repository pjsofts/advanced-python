{"pageProps":{"post":{"attributes":{"title":"Multithreading 2","description":"Multithreading 2"},"html":"<p>Let&#39;s delve deeper into multithreading in Python and explore more concepts and functionalities.</p>\n<h3 id=\"thread-synchronization\">Thread Synchronization:</h3>\n<h4 id=\"locks\">Locks:</h4>\n<p>Locks, represented by <code>threading.Lock()</code>, are used to prevent multiple threads from accessing shared resources concurrently, ensuring data integrity. Acquire a lock using <code>lock.acquire()</code> and release it using <code>lock.release()</code>.</p>\n<pre><code class=\"language-python\">import threading\n\nshared_resource = 0\nlock = threading.Lock()\n\ndef modify_shared_resource():\n    global shared_resource\n    for _ in range(100000):\n        lock.acquire()\n        shared_resource += 1\n        lock.release()\n\nthreads = [threading.Thread(target=modify_shared_resource) for _ in range(5)]\n\nfor thread in threads:\n    thread.start()\n\nfor thread in threads:\n    thread.join()\n\nprint(f&quot;Final shared resource value: {shared_resource}&quot;)  # Expected output: 500000\n</code></pre>\n<h4 id=\"rlocks-reentrant-locks\">RLocks (Reentrant Locks):</h4>\n<p><code>threading.RLock()</code> is a reentrant lock that allows the same thread to acquire the lock multiple times, preventing deadlocks.</p>\n<pre><code class=\"language-python\">import threading\n\nlock = threading.RLock()\n\ndef foo():\n    with lock:\n        print(&quot;Acquired lock in foo&quot;)\n        bar()\n\ndef bar():\n    with lock:\n        print(&quot;Acquired lock in bar&quot;)\n\nfoo()\n</code></pre>\n<h3 id=\"thread-communication\">Thread Communication:</h3>\n<h4 id=\"condition-variables\">Condition Variables:</h4>\n<p>Condition variables (<code>threading.Condition()</code>) are used to coordinate between multiple threads. They allow threads to wait until notified by another thread.</p>\n<pre><code class=\"language-python\">import threading\n\ncondition = threading.Condition()\nshared_queue = []\n\ndef producer():\n    for i in range(10):\n        with condition:\n            shared_queue.append(i)\n            condition.notify()  # Notify the consumer\n            condition.wait()  # Wait for consumer signal\n\ndef consumer():\n    for _ in range(10):\n        with condition:\n            while not shared_queue:\n                condition.wait()  # Wait for producer signal\n            print(f&quot;Consumed: {shared_queue.pop()}&quot;)\n            condition.notify()  # Notify the producer\n\nproducer_thread = threading.Thread(target=producer)\nconsumer_thread = threading.Thread(target=consumer)\n\nproducer_thread.start()\nconsumer_thread.start()\n\nproducer_thread.join()\nconsumer_thread.join()\n</code></pre>\n<h4 id=\"event-objects\">Event Objects:</h4>\n<p>Event objects (<code>threading.Event()</code>) allow threads to wait for an event to be set or cleared by other threads.</p>\n<pre><code class=\"language-python\">import threading\nimport time\n\nevent = threading.Event()\n\ndef wait_for_event():\n    print(&quot;Waiting for event to be set&quot;)\n    event.wait()\n    print(&quot;Event set!&quot;)\n\ndef set_event():\n    time.sleep(3)\n    print(&quot;Event is set&quot;)\n    event.set()\n\nthread1 = threading.Thread(target=wait_for_event)\nthread2 = threading.Thread(target=set_event)\n\nthread1.start()\nthread2.start()\n\nthread1.join()\nthread2.join()\n</code></pre>\n<h3 id=\"thread-local-data\">Thread-local Data:</h3>\n<p>Thread-local data (<code>threading.local()</code>) allows data to be stored and accessed on a per-thread basis, avoiding interference between threads.</p>\n<pre><code class=\"language-python\">import threading\n\nlocal_data = threading.local()\n\ndef set_data(value):\n    local_data.value = value\n\ndef print_data():\n    print(f&quot;Data in thread: {threading.current_thread().name} - {local_data.value}&quot;)\n\nthread1 = threading.Thread(target=set_data, args=(5,))\nthread2 = threading.Thread(target=set_data, args=(10,))\nthread3 = threading.Thread(target=print_data)\n\nthread1.start()\nthread2.start()\nthread3.start()\n\nthread1.join()\nthread2.join()\nthread3.join()\n</code></pre>\n<h3 id=\"summary\">Summary:</h3>\n<ul>\n<li>Thread synchronization mechanisms such as locks, RLocks, condition variables, and event objects help manage shared resources and coordinate between threads.</li>\n<li>Thread-local data (<code>threading.local()</code>) allows data to be stored separately for each thread.</li>\n<li>Understanding these concepts is crucial for building concurrent and thread-safe applications in Python.</li>\n</ul>\n","markdown":"\nLet's delve deeper into multithreading in Python and explore more concepts and functionalities.\n\n### Thread Synchronization:\n\n#### Locks:\n\nLocks, represented by `threading.Lock()`, are used to prevent multiple threads from accessing shared resources concurrently, ensuring data integrity. Acquire a lock using `lock.acquire()` and release it using `lock.release()`.\n\n```python\nimport threading\n\nshared_resource = 0\nlock = threading.Lock()\n\ndef modify_shared_resource():\n    global shared_resource\n    for _ in range(100000):\n        lock.acquire()\n        shared_resource += 1\n        lock.release()\n\nthreads = [threading.Thread(target=modify_shared_resource) for _ in range(5)]\n\nfor thread in threads:\n    thread.start()\n\nfor thread in threads:\n    thread.join()\n\nprint(f\"Final shared resource value: {shared_resource}\")  # Expected output: 500000\n```\n\n#### RLocks (Reentrant Locks):\n\n`threading.RLock()` is a reentrant lock that allows the same thread to acquire the lock multiple times, preventing deadlocks.\n\n```python\nimport threading\n\nlock = threading.RLock()\n\ndef foo():\n    with lock:\n        print(\"Acquired lock in foo\")\n        bar()\n\ndef bar():\n    with lock:\n        print(\"Acquired lock in bar\")\n\nfoo()\n```\n\n### Thread Communication:\n\n#### Condition Variables:\n\nCondition variables (`threading.Condition()`) are used to coordinate between multiple threads. They allow threads to wait until notified by another thread.\n\n```python\nimport threading\n\ncondition = threading.Condition()\nshared_queue = []\n\ndef producer():\n    for i in range(10):\n        with condition:\n            shared_queue.append(i)\n            condition.notify()  # Notify the consumer\n            condition.wait()  # Wait for consumer signal\n\ndef consumer():\n    for _ in range(10):\n        with condition:\n            while not shared_queue:\n                condition.wait()  # Wait for producer signal\n            print(f\"Consumed: {shared_queue.pop()}\")\n            condition.notify()  # Notify the producer\n\nproducer_thread = threading.Thread(target=producer)\nconsumer_thread = threading.Thread(target=consumer)\n\nproducer_thread.start()\nconsumer_thread.start()\n\nproducer_thread.join()\nconsumer_thread.join()\n```\n\n#### Event Objects:\n\nEvent objects (`threading.Event()`) allow threads to wait for an event to be set or cleared by other threads.\n\n```python\nimport threading\nimport time\n\nevent = threading.Event()\n\ndef wait_for_event():\n    print(\"Waiting for event to be set\")\n    event.wait()\n    print(\"Event set!\")\n\ndef set_event():\n    time.sleep(3)\n    print(\"Event is set\")\n    event.set()\n\nthread1 = threading.Thread(target=wait_for_event)\nthread2 = threading.Thread(target=set_event)\n\nthread1.start()\nthread2.start()\n\nthread1.join()\nthread2.join()\n```\n\n### Thread-local Data:\n\nThread-local data (`threading.local()`) allows data to be stored and accessed on a per-thread basis, avoiding interference between threads.\n\n```python\nimport threading\n\nlocal_data = threading.local()\n\ndef set_data(value):\n    local_data.value = value\n\ndef print_data():\n    print(f\"Data in thread: {threading.current_thread().name} - {local_data.value}\")\n\nthread1 = threading.Thread(target=set_data, args=(5,))\nthread2 = threading.Thread(target=set_data, args=(10,))\nthread3 = threading.Thread(target=print_data)\n\nthread1.start()\nthread2.start()\nthread3.start()\n\nthread1.join()\nthread2.join()\nthread3.join()\n```\n\n### Summary:\n\n- Thread synchronization mechanisms such as locks, RLocks, condition variables, and event objects help manage shared resources and coordinate between threads.\n- Thread-local data (`threading.local()`) allows data to be stored separately for each thread.\n- Understanding these concepts is crucial for building concurrent and thread-safe applications in Python.","slug":"Multithreading2","title":"Multithreading 2","section":"Concurrency","icon":"info-circle","filePath":"/home/runner/work/advanced-python/advanced-python/lessons/07-Concurrency/03-Multithreading2.md","nextSlug":"/advanced-python/lessons/Concurrency/Multiprocessing","prevSlug":"/advanced-python/lessons/Concurrency/Multithreading1"}},"__N_SSG":true}