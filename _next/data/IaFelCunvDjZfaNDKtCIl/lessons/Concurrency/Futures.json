{"pageProps":{"post":{"attributes":{"title":"Futures","description":"Futures"},"html":"<p>In Python, <code>Futures</code> are a high-level interface for asynchronously executing a callable (a function or method) and obtaining its eventual result. They are a part of the <code>concurrent.futures</code> module, which provides a high-level interface for asynchronously executing functions.</p>\n<h3 id=\"usage-of-futures\">Usage of Futures:</h3>\n<h4 id=\"1-asynchronous-execution\">1. Asynchronous Execution:</h4>\n<p>Futures allow you to execute a function asynchronously without blocking the main thread. This is particularly useful when dealing with I/O-bound tasks or running multiple functions concurrently.</p>\n<h4 id=\"2-obtaining-results\">2. Obtaining Results:</h4>\n<p>They provide a way to retrieve the result of a function once it has finished executing asynchronously.</p>\n<h3 id=\"example-using-concurrentfuturesfuture\">Example Using <code>concurrent.futures.Future</code>:</h3>\n<pre><code class=\"language-python\">import concurrent.futures\n\n# Define a function to be executed asynchronously\ndef square(n):\n    return n * n\n\n# Create a ThreadPoolExecutor (can also use ProcessPoolExecutor)\nwith concurrent.futures.ThreadPoolExecutor() as executor:\n    # Submit the function for execution asynchronously\n    future = executor.submit(square, 5)\n\n    # Do other tasks while &#39;square&#39; is running asynchronously\n    # ...\n\n    # Obtain the result once the function execution is finished\n    result = future.result()\n    print(result)  # Output: 25\n</code></pre>\n<p>In this example:</p>\n<ul>\n<li><code>executor.submit(square, 5)</code> submits the <code>square</code> function with an argument <code>5</code> for asynchronous execution and returns a <code>Future</code> object.</li>\n<li>While the function is running asynchronously, you can perform other tasks.</li>\n<li><code>future.result()</code> blocks until the function is complete and returns the result.</li>\n</ul>\n<h3 id=\"key-methods-and-attributes-of-concurrentfuturesfuture\">Key Methods and Attributes of <code>concurrent.futures.Future</code>:</h3>\n<ul>\n<li><strong><code>result()</code>:</strong> Waits for the function to complete and returns its result. It blocks until the result is available.</li>\n<li><strong><code>done()</code>:</strong> Returns <code>True</code> if the function has completed execution.</li>\n<li><strong><code>cancel()</code>:</strong> Attempts to cancel the execution of the function. Returns <code>True</code> if successful.</li>\n<li><strong><code>exception()</code>:</strong> Returns the exception raised by the function (if any) or <code>None</code> if no exception occurred.</li>\n<li><strong><code>add_done_callback(fn)</code>:</strong> Adds a callback function to be executed when the <code>Future</code> is completed.</li>\n</ul>\n<h3 id=\"types-of-executors\">Types of Executors:</h3>\n<p>Python&#39;s <code>concurrent.futures</code> module provides two types of executors:</p>\n<ol>\n<li><strong>ThreadPoolExecutor:</strong> Executes tasks in a pool of threads.</li>\n<li><strong>ProcessPoolExecutor:</strong> Executes tasks in a pool of processes.</li>\n</ol>\n<h3 id=\"considerations\">Considerations:</h3>\n<ul>\n<li>Futures are suitable for I/O-bound tasks where waiting for I/O operations is the main bottleneck.</li>\n<li>For CPU-bound tasks, the Global Interpreter Lock (GIL) in CPython limits the actual parallelism due to which <code>ProcessPoolExecutor</code> might be more effective than <code>ThreadPoolExecutor</code>.</li>\n</ul>\n<p>Futures in Python offer a convenient way to perform tasks asynchronously, allowing for more efficient resource utilization and improved responsiveness in I/O-bound scenarios.</p>\n","markdown":"\nIn Python, `Futures` are a high-level interface for asynchronously executing a callable (a function or method) and obtaining its eventual result. They are a part of the `concurrent.futures` module, which provides a high-level interface for asynchronously executing functions.\n\n### Usage of Futures:\n\n#### 1. Asynchronous Execution:\n\nFutures allow you to execute a function asynchronously without blocking the main thread. This is particularly useful when dealing with I/O-bound tasks or running multiple functions concurrently.\n\n#### 2. Obtaining Results:\n\nThey provide a way to retrieve the result of a function once it has finished executing asynchronously.\n\n### Example Using `concurrent.futures.Future`:\n\n```python\nimport concurrent.futures\n\n# Define a function to be executed asynchronously\ndef square(n):\n    return n * n\n\n# Create a ThreadPoolExecutor (can also use ProcessPoolExecutor)\nwith concurrent.futures.ThreadPoolExecutor() as executor:\n    # Submit the function for execution asynchronously\n    future = executor.submit(square, 5)\n\n    # Do other tasks while 'square' is running asynchronously\n    # ...\n\n    # Obtain the result once the function execution is finished\n    result = future.result()\n    print(result)  # Output: 25\n```\n\nIn this example:\n\n- `executor.submit(square, 5)` submits the `square` function with an argument `5` for asynchronous execution and returns a `Future` object.\n- While the function is running asynchronously, you can perform other tasks.\n- `future.result()` blocks until the function is complete and returns the result.\n\n### Key Methods and Attributes of `concurrent.futures.Future`:\n\n- **`result()`:** Waits for the function to complete and returns its result. It blocks until the result is available.\n- **`done()`:** Returns `True` if the function has completed execution.\n- **`cancel()`:** Attempts to cancel the execution of the function. Returns `True` if successful.\n- **`exception()`:** Returns the exception raised by the function (if any) or `None` if no exception occurred.\n- **`add_done_callback(fn)`:** Adds a callback function to be executed when the `Future` is completed.\n\n### Types of Executors:\n\nPython's `concurrent.futures` module provides two types of executors:\n\n1. **ThreadPoolExecutor:** Executes tasks in a pool of threads.\n2. **ProcessPoolExecutor:** Executes tasks in a pool of processes.\n\n### Considerations:\n\n- Futures are suitable for I/O-bound tasks where waiting for I/O operations is the main bottleneck.\n- For CPU-bound tasks, the Global Interpreter Lock (GIL) in CPython limits the actual parallelism due to which `ProcessPoolExecutor` might be more effective than `ThreadPoolExecutor`.\n\nFutures in Python offer a convenient way to perform tasks asynchronously, allowing for more efficient resource utilization and improved responsiveness in I/O-bound scenarios.","slug":"Futures","title":"Futures","section":"Concurrency","icon":"info-circle","filePath":"/home/runner/work/advanced-python/advanced-python/lessons/07-Concurrency/01-Futures.md","nextSlug":"/advanced-python/lessons/Concurrency/Multithreading1","prevSlug":"/advanced-python/lessons/Object-Oriented-Programming/OOP2"}},"__N_SSG":true}