{"pageProps":{"post":{"attributes":{"title":"Multithreading 1","description":"Multithreading 1"},"html":"<p>Let&#39;s start with the basics of multithreading in Python.</p>\n<h3 id=\"multithreading-in-python\">Multithreading in Python:</h3>\n<h4 id=\"1-threading-module\">1. <strong>Threading Module:</strong></h4>\n<p>Python&#39;s <code>threading</code> module is used for creating and working with threads. Threads are separate flows of execution within a process. They can run concurrently and are useful for parallel execution of tasks.</p>\n<h4 id=\"2-creating-threads\">2. <strong>Creating Threads:</strong></h4>\n<p>You can create a thread by instantiating the <code>Thread</code> class and providing a target function to be executed in the new thread.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">import</span> threading\n\n<span class=\"hljs-comment\"># Function to be executed in a thread</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_numbers</span>():\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">5</span>):\n        <span class=\"hljs-built_in\">print</span>(i)\n\n<span class=\"hljs-comment\"># Create a thread</span>\nthread = threading.Thread(target=print_numbers)\n\n<span class=\"hljs-comment\"># Start the thread</span>\nthread.start()\n</code></pre>\n<h4 id=\"3-joining-threads\">3. <strong>Joining Threads:</strong></h4>\n<p>The <code>join()</code> method allows the main thread to wait until the thread being joined has completed its execution.</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-comment\"># Wait for the thread to finish its execution</span>\nthread.join()\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Thread execution completed&quot;</span>)\n</code></pre>\n<h4 id=\"4-thread-safety\">4. <strong>Thread Safety:</strong></h4>\n<p>When multiple threads share resources (like variables, data structures, etc.), thread safety becomes crucial. Synchronization mechanisms like locks (<code>Lock</code>, <code>RLock</code>), semaphores, and conditions are used to prevent race conditions and ensure data integrity.</p>\n<h4 id=\"example-with-lock\">Example with Lock:</h4>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-comment\"># Function with shared resource</span>\ncounter = <span class=\"hljs-number\">0</span>\nlock = threading.Lock()\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">increment</span>():\n    <span class=\"hljs-keyword\">global</span> counter\n    <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">100000</span>):\n        <span class=\"hljs-keyword\">with</span> lock:\n            counter += <span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-comment\"># Create multiple threads</span>\nthreads = [threading.Thread(target=increment) <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">5</span>)]\n\n<span class=\"hljs-comment\"># Start the threads</span>\n<span class=\"hljs-keyword\">for</span> thread <span class=\"hljs-keyword\">in</span> threads:\n    thread.start()\n\n<span class=\"hljs-comment\"># Wait for all threads to finish</span>\n<span class=\"hljs-keyword\">for</span> thread <span class=\"hljs-keyword\">in</span> threads:\n    thread.join()\n\n<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;Counter value: <span class=\"hljs-subst\">{counter}</span>&quot;</span>)  <span class=\"hljs-comment\"># Expected output: 500000</span>\n</code></pre>\n<h4 id=\"important-points\">Important Points:</h4>\n<ul>\n<li>Python&#39;s Global Interpreter Lock (GIL) allows only one thread to execute Python bytecode at a time in a single process, limiting true parallelism in CPU-bound tasks in CPython.</li>\n<li>Multithreading in Python is effective for I/O-bound tasks where threads can wait for I/O operations without blocking other threads.</li>\n</ul>\n<h3 id=\"summary\">Summary:</h3>\n<p>Multithreading in Python allows concurrent execution of tasks, useful for I/O-bound operations and tasks requiring parallelism without being CPU-bound. It&#39;s important to manage shared resources carefully using synchronization mechanisms to avoid data corruption in multithreaded applications.</p>\n","markdown":"\nLet's start with the basics of multithreading in Python.\n\n### Multithreading in Python:\n\n#### 1. **Threading Module:**\n\nPython's `threading` module is used for creating and working with threads. Threads are separate flows of execution within a process. They can run concurrently and are useful for parallel execution of tasks.\n\n#### 2. **Creating Threads:**\n\nYou can create a thread by instantiating the `Thread` class and providing a target function to be executed in the new thread.\n\n```python\nimport threading\n\n# Function to be executed in a thread\ndef print_numbers():\n    for i in range(5):\n        print(i)\n\n# Create a thread\nthread = threading.Thread(target=print_numbers)\n\n# Start the thread\nthread.start()\n```\n\n#### 3. **Joining Threads:**\n\nThe `join()` method allows the main thread to wait until the thread being joined has completed its execution.\n\n```python\n# Wait for the thread to finish its execution\nthread.join()\nprint(\"Thread execution completed\")\n```\n\n#### 4. **Thread Safety:**\n\nWhen multiple threads share resources (like variables, data structures, etc.), thread safety becomes crucial. Synchronization mechanisms like locks (`Lock`, `RLock`), semaphores, and conditions are used to prevent race conditions and ensure data integrity.\n\n#### Example with Lock:\n\n```python\n# Function with shared resource\ncounter = 0\nlock = threading.Lock()\n\ndef increment():\n    global counter\n    for _ in range(100000):\n        with lock:\n            counter += 1\n\n# Create multiple threads\nthreads = [threading.Thread(target=increment) for _ in range(5)]\n\n# Start the threads\nfor thread in threads:\n    thread.start()\n\n# Wait for all threads to finish\nfor thread in threads:\n    thread.join()\n\nprint(f\"Counter value: {counter}\")  # Expected output: 500000\n```\n\n#### Important Points:\n\n- Python's Global Interpreter Lock (GIL) allows only one thread to execute Python bytecode at a time in a single process, limiting true parallelism in CPU-bound tasks in CPython.\n- Multithreading in Python is effective for I/O-bound tasks where threads can wait for I/O operations without blocking other threads.\n\n### Summary:\n\nMultithreading in Python allows concurrent execution of tasks, useful for I/O-bound operations and tasks requiring parallelism without being CPU-bound. It's important to manage shared resources carefully using synchronization mechanisms to avoid data corruption in multithreaded applications.","slug":"Multithreading1","title":"Multithreading 1","section":"Concurrency","icon":"info-circle","filePath":"/home/runner/work/advanced-python/advanced-python/lessons/07-Concurrency/02-Multithreading1.md","nextSlug":"/advanced-python/lessons/Concurrency/Multithreading2","prevSlug":"/advanced-python/lessons/Concurrency/Futures"}},"__N_SSG":true}